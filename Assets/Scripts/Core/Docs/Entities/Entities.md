# [Work in progress]

---

# Entities

## TL;DR

- Entities are basically used in the ECS framework of choice (in this particular case, `DefaultECS`) like `GameObjects` in Unity with an extra layer of abstraction
- Basic ECS framework entities exist in one particular world and may have some kind of built-in ID value that may be as simple as an integer, or may be a complex structure consisting of array index and generation counter etc.
- In this framework we treat entities as if they may be (or may be not) present across multiple worlds at the same time to force the separation of concerns and to make the code more modular and reusable
- To create an entity, use IEntityManager. It allows to get, create or delete either a 'world-local' entity (i.e. the one that lives in one world only) or an entity with a register (i.e. the one that may be present in multiple worlds at the same time)
- Entities with a register share an ID component with an ID value between its world representations and an entity in the `Registry world` that contains components with references to particular worlds the entity is present in
- Entity ID generic type is used to provide the connection between entity's representation across different worlds. You can use entity ID as a unique identifier value to get the entity in any world it has been registered in, including the `Registry world`. The options for entity ID include but are not limited to, `Guid`, `integer`, `unsigned integer`, `short`, `unsigned short`, `string` etc. The ability to identify the entity by its unique ID is particularly useful for networking and serialization purposes
- Entity managers also work as world repositories, providing the ability to find and interact with a particular entity world by its ID
- The most common worlds that are present in virtually every project include:
  - `Registry world` - the world that contains the entities with links to the worlds they are present in
  - `Simulation world` - the world where the game logic is executed
  - `View world` - the world that contains the entities that are used in a visual representation of the game
  - `Event world` - the world that contains the entities that are used to store the events that are happening in the game
- Basically what that means is that `Simulation world` is a collection of your regular `GameObjects` (now `Entities`) with `MonoBehaviour`s being components stripped of all logic (now `Components`) that is instead moved into `Systems`. `View world` is the same but containing only Unity's built-in `MeshRenderers`, `SpriteRenderers`, `UI Texts` and other visual stuff. `Event world` is storing `Unity Events` kind of stuff as if they were separate `GameObjects` - more on that later
- Why all the hassle and not use regular `GameObjects`? For several purposes:
  - Separation of logic from data allows to enforce `Data-Oriented Design` where the data is stored in a way that is easy to process by the CPU. Basically something akin to `SQL` tables: each component type is a table and each component of that type is a row. Imagine that your warrior's `Health` component is an element at `All healths` table at index #5, containing data of 300 HP out of maximum of 500, while the neighbouring rows contain health data of enemy mobs or friendly units alike
  - Data that is stripped of all logic is extremely easy to serialize into any kind of media and back or marshalled between applications as long as its size is predetermined (no dynamic arrays) and its variable types are blittable (so no reference types). It can be stored in a binary object, a JSON, a CSV, an XML, sent or received as a byte array, copied with a shallow copy into a cloned object etc.
  - The logic that is separate from the data allows to interchange the systems that operate on entities in runtime without modifying entities themself - as long as they contain the data they preserve their state despite the amount and type of systems you may utilize at any given moment. For instance, you may be using some `Projectile locomotion` system that moves all projectiles along the line in the direction they're facing, then suddenly dispose the system leaving the bullets levitating in the air then finally turn on the `Gravity` system that will pull all the levitating bullets to the ground. Yes, Neo was a master ECS user
  - You may use the same logic (`System`) for any given entity that matches the requirements (a `Query`, a `Set` or a `Filter`). What most systems do is they performing a basic `for` loop on each entity in the array of matching entities and do the same operation on each and every one of them.
  >See those birds? At some point a program was written to govern them. A program was written to watch over the trees and the winds, sunrise and sunset. Their programs running all over the place. &#169;Pytheas, The Matrix 2
  - The presence or absence of particular components define the entity's behaviour while storing its state for said behaviours at the same time. Of course that would not work without `Systems` to update them but the crucial part is changing the behaviour is achieved by changing the components attached to particular entity which is a risk free process due to natural absence of dependencies in the raw data that components are
  - `Data-Oriented Design` (or `DOD`) is crucial for
    - Networking, as the data you send or receive is the data you have, free of context and dependencies
	- Serializing and storing large worlds
	- Multithreading as the same for loop can be split into multiple jobs that do the same thing on the different portions of the array on different threads (although it may not be as easy as it's written, more on that later)
	- Performance as looping over an array inside a so called `struct-of-arrays` allows to utilize cache coherence and L1 CPU cache to the maximum of its abilities (as long as the components are relatively small in size)
- Then why not use one and the same `World` for all of the components that may be attached to the entity? Why not storing `MeshRenderer` together with `Locomotion` component, for instance?
  - The game logic thing you may write for entity's behaviour is its so-called `Model` part (other names include `Domain logic` and `Business logic`). What does a model _need_ to operate (or in other words, What does it _care_ about)? Numbers. Digits. Signs. Hash values. Maybe strings. The only thing your health system cares about is your current HP, your max HP and the change in HP if you're either hurt or healed. It does not know and neither care if your character has a HP bar, an animation that accompanies the health change event, whether it should print a text log in a chat if you've received damage. It only adds or substracts values, clamps them, maybe does some magic but that's all it needs - a bunch of numbers.
  - For the same reason the entire game may be stripped down of all of its `View` parts (those are being basically anything you see on the screen) and _still_ be operational. Yes, you may just unplug the screen and keep on pressing the buttons - as long as the `Model` parts reads your input and retains its relevant data you may still be playing the game
  - That's basically what any `headless` server game build does. It does not need a GPU to run the game. It receives packets, runs the simulation, sends the updates back
  - What's more important is that as long as you have a properly working `Model` you can attach __any__ view of your choice, replace it, modify it and the game will not change its operation. __The model logic MUST NOT be dependent on the view logic - the view must be dependent on the model__. Obviously you may want things in the model part to be synchronized with the view at some point or even reveice input from it (like when a user drags the slider and your corresponding value should change with it) but still there general rule applies and you may achieve your goal without sacrificing the model integrity
  - That also allows to reuse the same views for different models. You neither need to make the same button nor change its operation for each new game you make. It looks like a button, clicks, it sends a message. Change what it sends those messages to and you have saved yourself a lot of time and effort
  - Separating `Model` and `View` parts makes your code more compliant to `SOLID` rules, especially `Single Responsibility Principle` and `Open/Closed Principle`. It untwingles the spaghetti of mixed model and view behaviours in methods that are commonly present in regular object oriented classes that take progressively more time to modify or refactor each time a new requirement from the game designer arrives
  - It also allows to test the model part in isolation from the view part. You may write a test that checks if the health system works as intended without the need to create a `GameObject` with a `Health` component, a `MeshRenderer` and a `HealthView` script that listens to the `Health` component changes and updates the `MeshRenderer` accordingly. You may just create a `Health` component, create a `HealthSystem` and test if the system changes the `Health` component as intended //wow thanks, Copilot
  - The `DODs` achiles heel is the event handling. In `ECS` you can't have the same component type attached to the same entity more than once, delegate being a reference type (it's basically a reference to a method) is not a good thing to store in the data-only components and the `Systems` are not meant to be used as event listeners. That's why the `Event world` is a thing - it stores the events that are happening in the game and the `Systems` that are interested in those events are listening to the `Event world` instead of the `Simulation world` where the game logic is executed. It allows to have events that affect both single entities (like stabbing a goblin) and multiple entities (like grenade explosion taking out a bunch of goblins), multiple events that affect the same entity (like a goblin being stabbed by two knights and naded by a mage at the same time) and the events that are not tied to any particular entity (like game start, game end, level change etc.)
  - The `Registry world` takes care of keeping track of the entities representations and allows to add or remove such representations in runtime. For instance, if your character drank an invisibility potion, it still exists leaving the simulation entity intact while the view entity may be despawned completely (there is basically nothing to look at) or replaced with a view entity that does 'poof' with some VFXes and then disappears
  - The world local entities that do not require registry can still interact with entities that have a representation within the same world. For instance, unless you're having a stealth in your game, you don't need the bush to be a simulation entity, its only purpose is to artistically enrich the environment. However you do want it to rattle once your character touches it. That's why it should live in the `View world` and interact with player's `View world` entity
  - Each new world provides extra context in which it separates the concern and operates with entities within without affecting the rest of their representations in a direct manner. For instance, you're making a PVP shooter and you want to know __where your client thinks his character is__ as well as __where the server thinks he is__ to perform reconciliation, extrapolation and other client-server logic. ECS entities cannot store the same type of component more than once so you can't have two different `Position` components on the player character's simulation entity. Instead you could put the server's knowledge of your character into `Server world` entity representation and update the simulation entity based on its values. You may event have both of them drawn in wireframe separately in a view world to see the difference based on ping, lag, packet loss etc. Convenient and effective